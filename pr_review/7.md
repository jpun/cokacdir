# PR #7 Review

## 개요

- **변경 파일**: 3개 (`src/services/audit.rs` 신규, `src/services/mod.rs` 수정, `src/services/telegram.rs` 수정)
- **PR base와 현재 main 비교**: 구조적 차이 있음 (PR이 이전 버전 기반)
- **변경 성격**: 텔레그램 봇에 커맨드 감사 로깅(audit logging) 기능 추가
- **핵심 기능**: 모든 텔레그램 커맨드를 `~/.cokacdir/audit.log`에 위험도 분류와 함께 기록

---

## PR base(before)와 현재 main의 차이

PR 작성자는 현재 main보다 이전 버전의 코드에서 작업했다. 주요 차이점:

### `src/services/telegram.rs`

| 항목 | PR base (before) | 현재 main |
|------|------------------|-----------|
| `ChatSession` struct | `#[derive(Clone)]` 없음 | `#[derive(Clone)]` 있음 |
| `BotSettings` 필드 | `allowed_tools`, `last_sessions`, `owner_user_id`, `as_public_for_group_chat` | 위 4개 + `models: HashMap<String, String>`, `debug: bool` 추가 |
| 파일 규모 | ~510행 부근에서 커맨드 핸들링 시작 | ~948행 부근에서 커맨드 핸들링 시작 |
| 추가된 기능 | - | 스케줄링, rate limit, model 선택, debug 토글 등 |

### `src/services/mod.rs`

- PR base와 현재 main이 **완전히 동일** (충돌 없음)

### 의존성 (`Cargo.toml`)

- `audit.rs`가 사용하는 `dirs`와 `chrono` 크레이트는 현재 main의 `Cargo.toml`에 **이미 존재** (추가 의존성 불필요)

---

## 변경 파일 상세

### 변경 1: 신규 파일 `src/services/audit.rs` (34줄)

```rust
use std::fs::{self, OpenOptions};
use std::io::Write;

/// Log a command execution to the audit trail.
/// File: ~/.cokacdir/audit.log, permissions 0o600
pub fn log_command(user_id: u64, chat_id: i64, risk: &str, command: &str) {
    let Some(home) = dirs::home_dir() else {
        return;
    };
    let log_dir = home.join(".cokacdir");
    let log_path = log_dir.join("audit.log");

    let _ = fs::create_dir_all(&log_dir);

    let timestamp = chrono::Local::now().format("%Y-%m-%d %H:%M:%S");
    let cmd_preview: String = command.chars().take(200).collect();
    let line = format!("[{timestamp}] user={user_id} chat={chat_id} risk={risk} cmd={cmd_preview}\n");

    let Ok(mut file) = OpenOptions::new().create(true).append(true).open(&log_path) else {
        return;
    };
    let _ = file.write_all(line.as_bytes());

    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        if let Ok(metadata) = fs::metadata(&log_path) {
            let mut perms = metadata.permissions();
            perms.set_mode(0o600);
            let _ = fs::set_permissions(&log_path, perms);
        }
    }
}
```

**기능**: `~/.cokacdir/audit.log`에 텔레그램 커맨드 실행 기록을 append. Unix에서 파일 권한 0o600 설정.

**로그 형식 예시**:
```
[2026-02-25 14:30:00] user=123456 chat=-100999 risk=Dangerous cmd=!rm -rf /tmp/test
[2026-02-25 14:30:05] user=123456 chat=-100999 risk=Safe cmd=hello world
```

---

### 변경 2: `src/services/mod.rs` (1줄 추가)

```diff
+ pub mod audit;
  pub mod file_ops;
  pub mod process;
  pub mod claude;
  pub mod remote;
  pub mod remote_transfer;
  pub mod dedup;
  pub mod telegram;
```

---

### 변경 3: `src/services/telegram.rs` (2곳 수정)

**수정 A - import 추가 (12행 뒤)**:

```diff
  use sha2::{Sha256, Digest};

+ use crate::services::audit;
  use crate::services::claude::{self, CancelToken, StreamMessage, DEFAULT_ALLOWED_TOOLS};
```

**수정 B - audit 로깅 블록 삽입** (AI request in progress 체크 직후, `/stop` 핸들러 직전):

PR base에서의 위치 (510행 뒤):
```rust
        }
    }

    // Audit log: record every command with risk classification  // ← 여기부터 삽입
    {
        let risk_str = if text.starts_with("!") {
            "Dangerous"
        } else if text.starts_with("/allowed") || text.starts_with("/public") {
            "Dangerous"
        } else if text.starts_with("/start") || text.starts_with("/cd") || text.starts_with("/down") {
            "Elevated"
        } else {
            "Safe"
        };
        audit::log_command(uid, chat_id.0, risk_str, &text);
    }
                                                                 // ← 여기까지

    if text.starts_with("/stop") {
```

현재 main에서의 대응 위치 (946행 뒤):
```rust
        }
    }
                    // ← 현재 main의 947행 (빈 줄). 여기에 삽입하면 됨
    if text.starts_with("/stop") {
```

**삽입 지점의 코드 패턴이 PR base와 현재 main에서 완전히 동일하므로 충돌 없이 적용 가능.**

사용하는 변수 `uid` (u64)와 `chat_id` (ChatId)는 현재 main의 해당 스코프에 동일한 이름과 타입으로 존재한다.

---

## 위험도 분류 로직 분석

PR은 커맨드를 3단계로 분류한다:

| 위험도 | 조건 | 해당 커맨드 |
|--------|------|-------------|
| Dangerous | `text.starts_with("!")` | 쉘 커맨드 직접 실행 |
| Dangerous | `text.starts_with("/allowed")` 또는 `text.starts_with("/public")` | 권한 설정 변경 |
| Elevated | `text.starts_with("/start")` 또는 `text.starts_with("/cd")` 또는 `text.starts_with("/down")` | 세션 시작, 디렉토리 이동 |
| Safe | 그 외 모든 것 | AI 프롬프트, /help, /clear 등 |

### 이 분류의 근본적 문제점

**명령어의 의미는 자연어에 준하는 수준으로 다양하다. 단순 문자열 prefix 비교로는 의미를 파악할 수 없다.**

구체적으로:

1. **쉘 커맨드의 위험도 편차 무시**: `!ls`(무해)와 `!rm -rf /`(치명적)가 동일한 "Dangerous". 위험하지 않은 명령에도 항상 경보가 울리면 감사 로그의 신뢰성이 떨어진다.

2. **AI 프롬프트가 "Safe"로 분류되는 오류**: 일반 텍스트 입력(AI 프롬프트)은 전부 "Safe"이지만, 사용자가 "서버의 모든 파일을 삭제해줘"라고 입력하면 Claude가 tool use를 통해 실제로 실행할 수 있다. 이것이 실질적으로 가장 위험한 경로인데 "Safe"로 분류된다.

3. **정적 분류의 한계**: 현재 main에 이미 추가된 `/model`, `/schedule`, `/debug` 등의 커맨드가 분류에 반영되지 않았고, 향후 추가되는 커맨드도 자동으로 "Safe"로 빠진다.

4. **실행 결과와 무관**: 커맨드의 실제 위험도는 입력 시점이 아니라 실행 결과(어떤 tool이 호출되었는지, 어떤 파일/프로세스에 접근했는지)에 의해 결정된다. 입구에서 prefix로 분류하는 것은 의미 있는 보안 지표가 될 수 없다.

5. **잘못된 안전감 유발**: "Safe"라고 표시된 로그 항목이 실제로는 위험한 작업이었을 수 있어, 감사 로그를 검토하는 사람에게 오해를 줄 수 있다.

**결론: 위험도 분류(risk classification)는 불필요한 엔지니어링이다. 커맨드의 의미를 제대로 평가하려면 LLM 기반 의미 해석이나 실행 시점의 tool use 기반 사후 평가가 필요하며, 단순 prefix 매칭으로는 정확한 분류가 불가능하다.**

---

## `audit.rs` 코드 품질 지적사항

### 1. 매 write마다 permissions 설정 (비효율)

```rust
// 현재: 매번 로그를 쓸 때마다 실행됨
#[cfg(unix)]
{
    use std::os::unix::fs::PermissionsExt;
    if let Ok(metadata) = fs::metadata(&log_path) {
        let mut perms = metadata.permissions();
        perms.set_mode(0o600);
        let _ = fs::set_permissions(&log_path, perms);
    }
}
```

파일 생성 시 한 번만 설정하면 충분하다. 매 로그 기록마다 `metadata()` + `set_permissions()` 시스템 콜을 2회씩 하는 것은 불필요하다.

### 2. 커맨드 미리보기 200자 제한

```rust
let cmd_preview: String = command.chars().take(200).collect();
```

200자는 임의의 숫자이며, 잘린 커맨드는 감사 목적에서 불완전한 기록이 된다. 전체 커맨드를 기록하거나, 자르는 경우 잘렸다는 표시(예: `...`)를 남기는 것이 좋다.

### 3. 로그 파일 크기 관리 없음

append-only로 계속 쌓이며 rotation이나 크기 제한이 없다. 장기 운용 시 무한히 커진다.

---

## 종합 평가

| # | 항목 | 평가 |
|---|------|------|
| 1 | 로그를 남기는 개념 자체 | **좋음**. 텔레그램 봇 커맨드 감사 추적은 유용 |
| 2 | risk 분류 로직 | **제거 필요**. prefix 기반 분류는 부정확하고 불필요한 엔지니어링 |
| 3 | `audit.rs` 구현 품질 | permissions 반복 설정 비효율, 로그 rotation 부재 |
| 4 | 현재 main 적용 가능성 | **가능**. 삽입 지점의 코드 패턴이 동일하여 충돌 없음 |

---

## 적용 방법

### 권장: risk 분류 제거 후 순수 로깅만 적용

PR의 "누가/언제/어디서/무엇을" 기록하는 로깅 개념은 수용하되, risk 분류는 제거한다.

**수정된 `audit.rs`**:
```rust
use std::fs::{self, OpenOptions};
use std::io::Write;

/// Log a command execution to the audit trail.
/// File: ~/.cokacdir/audit.log
pub fn log_command(user_id: u64, chat_id: i64, command: &str) {
    let Some(home) = dirs::home_dir() else {
        return;
    };
    let log_dir = home.join(".cokacdir");
    let log_path = log_dir.join("audit.log");

    let _ = fs::create_dir_all(&log_dir);

    let timestamp = chrono::Local::now().format("%Y-%m-%d %H:%M:%S");
    let line = format!("[{timestamp}] user={user_id} chat={chat_id} cmd={command}\n");

    let Ok(mut file) = OpenOptions::new().create(true).append(true).open(&log_path) else {
        return;
    };
    let _ = file.write_all(line.as_bytes());

    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        if let Ok(metadata) = fs::metadata(&log_path) {
            let mut perms = metadata.permissions();
            perms.set_mode(0o600);
            let _ = fs::set_permissions(&log_path, perms);
        }
    }
}
```

변경점: `risk` 파라미터 제거, 200자 제한 제거, 로그 포맷에서 `risk=` 필드 제거.

**수정된 `telegram.rs` 삽입 코드**:
```rust
    // Audit log
    audit::log_command(uid, chat_id.0, &text);
```

risk 분류 블록 전체를 단일 호출로 대체.

### 적용 위치 (현재 main 기준)

1. `src/services/audit.rs` - 신규 생성 (위의 수정된 버전)
2. `src/services/mod.rs` 1행 - `pub mod audit;` 추가
3. `src/services/telegram.rs` 13행 - `use crate::services::audit;` 추가
4. `src/services/telegram.rs` 947행 (빈 줄) - `audit::log_command(uid, chat_id.0, &text);` 삽입
