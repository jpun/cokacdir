# PR #8 Review: 텔레그램 세션 파일 정리 기능

## 개요

- **변경 파일**: 1개 (`src/services/telegram.rs`)
- **변경 성격**: 세션 파일 디스크 관리 — 자동 정리 함수 추가 및 `/clear` 시 파일 삭제 방식 변경
- **PR base 기준**: 2753줄 (현재 main: 4222줄 — 약 1469줄 차이)
- **적용 가능 여부**: 적용 불가 — 아래 상세 사유 참조

---

## PR의 목적

텔레그램 봇의 **AI 세션 파일(`~/.cokacdir/ai_sessions/*.json`)의 디스크 관리**가 핵심이다.

두 가지 기능을 추가한다:

1. **봇 시작 시 오래된 세션 파일 자동 삭제** — 30일 초과 파일 일괄 정리
2. **`/clear` 명령 시 세션 파일 즉시 삭제** — session_id로 직접 파일 삭제

---

## 변경 내용 상세

### 변경 1: 봇 시작 시 `cleanup_stale_sessions(30)` 호출 추가

**위치**: PR base 287줄 (`Bot::new(token)` 직후)

```rust
let bot = Bot::new(token);
let bot_settings = load_bot_settings(token);

// Clean up session files older than 30 days on startup  ← 추가
cleanup_stale_sessions(30);                                ← 추가

// Register bot commands for autocomplete
```

**현재 main 대응 위치**: 680-688줄

```rust
let bot = Bot::new(token);
let bot_settings = load_bot_settings(token);

// Restore debug flag from saved settings
if bot_settings.debug {
    TG_DEBUG.store(true, Ordering::Relaxed);
    crate::services::claude::DEBUG_ENABLED.store(true, Ordering::Relaxed);
}

// Register bot commands for autocomplete
```

현재 main에는 동등한 기능이 **존재하지 않음**. 순수 신규 삽입.

---

### 변경 2: `/clear` 핸들러에서 세션 파일 삭제 로직 변경

**PR before (771-781줄)** — 메모리 상태만 정리, 디스크 파일은 건드리지 않음:

```rust
{
    let mut data = state.lock().await;
    if let Some(session) = data.sessions.get_mut(&chat_id) {
        session.session_id = None;
        session.history.clear();
        session.pending_uploads.clear();
        session.cleared = true;
    }
    data.cancel_tokens.remove(&chat_id);
    data.stop_message_ids.remove(&chat_id);
}
```

**PR after (774-792줄)** — session_id를 먼저 추출한 뒤, lock 해제 후 디스크 파일 삭제:

```rust
let session_id_to_delete = {
    let mut data = state.lock().await;
    let session_id = data.sessions.get(&chat_id)
        .and_then(|s| s.session_id.clone());      // ← session_id 추출
    if let Some(session) = data.sessions.get_mut(&chat_id) {
        session.session_id = None;
        session.history.clear();
        session.pending_uploads.clear();
        session.cleared = true;
    }
    data.cancel_tokens.remove(&chat_id);
    data.stop_message_ids.remove(&chat_id);
    session_id                                      // ← lock 밖으로 반환
};

// Also remove the session file from disk
if let Some(ref sid) = session_id_to_delete {
    delete_session_file(sid);                       // ← 디스크 삭제
}
```

**현재 main (1346-1378줄)** — 이미 디스크 파일 삭제가 구현되어 있음 (다른 방식):

```rust
let current_path = {
    let mut data = state.lock().await;
    let path = data.sessions.get(&chat_id).and_then(|s| s.current_path.clone());
    if let Some(session) = data.sessions.get_mut(&chat_id) {
        session.session_id = None;
        session.history.clear();
        session.pending_uploads.clear();
        session.cleared = true;
    }
    data.cancel_tokens.remove(&chat_id);
    data.stop_message_ids.remove(&chat_id);
    path
};

// Delete session file from disk so session_id is completely forgotten
if let Some(ref path) = current_path {
    if let Some(sessions_dir) = crate::ui::ai_screen::ai_sessions_dir() {
        if let Ok(entries) = fs::read_dir(&sessions_dir) {
            for entry in entries.filter_map(|e| e.ok()) {
                let file_path = entry.path();
                if file_path.extension().map(|e| e == "json").unwrap_or(false) {
                    if let Ok(content) = fs::read_to_string(&file_path) {
                        if let Ok(session_data) = serde_json::from_str::<SessionData>(&content) {
                            if session_data.current_path == *path {
                                let _ = fs::remove_file(&file_path);
                            }
                        }
                    }
                }
            }
        }
    }
}
```

**두 방식의 비교**:

| 항목 | PR 방식 | 현재 main 방식 |
|------|---------|---------------|
| 식별 키 | `session_id` (메모리에서 추출) | `current_path` (메모리에서 추출) |
| 파일 탐색 | `{session_id}.json` 직접 접근 | 디렉토리 전체 순회 + JSON 파싱 |
| 시간 복잡도 | O(1) | O(n) — n은 세션 파일 수 |
| session_id 없을 때 | 삭제 불가 (조용히 무시) | path 매칭으로 삭제 가능 |
| 고아 파일 처리 | 불가 | 가능 (내용 기반 매칭) |

현재 main 방식이 더 robust하다.

---

### 변경 3: 신규 함수 `cleanup_stale_sessions()`

```rust
fn cleanup_stale_sessions(max_age_days: u64) {
    let Some(sessions_dir) = ai_screen::ai_sessions_dir() else {
        return;
    };
    let Ok(entries) = fs::read_dir(&sessions_dir) else {
        return;
    };
    let cutoff = std::time::Duration::from_secs(max_age_days * 24 * 60 * 60);
    let mut deleted = 0u32;
    for entry in entries.filter_map(|e| e.ok()) {
        let path = entry.path();
        if path.extension().map(|e| e == "json").unwrap_or(false) {
            if let Ok(metadata) = path.metadata() {
                if let Ok(modified) = metadata.modified() {
                    if let Ok(age) = std::time::SystemTime::now().duration_since(modified) {
                        if age > cutoff {
                            if fs::remove_file(&path).is_ok() {
                                deleted += 1;
                            }
                        }
                    }
                }
            }
        }
    }
    if deleted > 0 {
        println!("  ✓ Cleaned up {deleted} stale session file(s) older than {max_age_days} days");
    }
}
```

**동작 방식**:
1. `ai_screen::ai_sessions_dir()`로 세션 디렉토리 경로 획득 (없으면 조기 return)
2. 디렉토리 내 모든 `.json` 파일을 순회
3. 각 파일의 **파일시스템 mtime** (마지막 수정 시간)을 읽음 — 파일 내용은 읽지 않음
4. `현재 시간 - mtime`이 `max_age_days × 86400초`를 초과하면 `fs::remove_file()`로 삭제
5. 삭제 건수가 1 이상이면 stdout에 로그 출력
6. 모든 에러(디렉토리 없음, 메타데이터 읽기 실패 등)는 무시(silent)

---

### 변경 4: 신규 함수 `delete_session_file()`

```rust
fn delete_session_file(session_id: &str) {
    let Some(sessions_dir) = ai_screen::ai_sessions_dir() else {
        return;
    };
    let file_path = sessions_dir.join(format!("{}.json", session_id));
    if let Some(parent) = file_path.parent() {
        if parent == sessions_dir {
            let _ = fs::remove_file(file_path);
        }
    }
}
```

**동작 방식**:
1. `ai_screen::ai_sessions_dir()`로 세션 디렉토리 경로 획득
2. `{sessions_dir}/{session_id}.json` 경로를 직접 구성
3. **Path traversal 방어**: `file_path.parent() == sessions_dir`를 검증하여, `session_id`에 `../` 등이 포함된 경우 세션 디렉토리 밖 파일 삭제를 차단
4. 검증 통과 시 `fs::remove_file()` 실행, 실패 시 무시

**참고**: session_id 자체의 문자 검증(sanitization)은 이 함수에서 하지 않음. 현재 main의 `save_session_to_file()` (2896-2898줄)에서 별도로 `session_id.chars().all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '_')` 검증을 하고 있어, 실질적으로 악의적 session_id가 저장될 가능성은 낮음.

---

## 적용 판단

### `cleanup_stale_sessions()` — 적용 불가

이 프로젝트의 워크스페이스는 스케줄 작업과 일반 작업 폴더를 포함하며, **폴더(및 관련 세션 파일)의 보존 기간은 사용자가 전적으로 결정해야 한다**. 30일이라는 기준으로 세션 파일을 자동 삭제하면:

- 사용자가 의도적으로 보존 중인 워크스페이스의 세션 히스토리가 본인 의사와 무관하게 소실됨
- 장기 프로젝트나 주기적 스케줄 작업의 세션 컨텍스트가 예고 없이 사라짐
- 데이터 삭제에 대한 사용자 동의/확인 절차가 전혀 없음

**프로그램이 사용자의 데이터 수명 결정권을 빼앗는 설계이므로 적용할 수 없다.**

### `delete_session_file()` 및 `/clear` 핸들러 변경 — 적용 불필요

현재 main의 `/clear` 핸들러(1346-1378줄)가 이미 세션 파일 디스크 삭제를 구현하고 있다. PR의 방식(session_id 직접 접근)이 O(1)로 더 효율적이지만, 현재 main의 방식(path 매칭 순회)이 더 robust하며 기능적으로 완전히 동등하다. 교체할 실익이 없다.

---

## 최종 결론

| 변경 항목 | 적용 여부 | 사유 |
|-----------|-----------|------|
| `cleanup_stale_sessions()` 함수 | 불가 | 사용자 데이터 보존 결정권 침해 |
| 봇 시작 시 호출 | 불가 | 위와 동일 |
| `/clear` 핸들러 변경 | 불필요 | 현재 main에 이미 더 robust한 구현 존재 |
| `delete_session_file()` 함수 | 불필요 | 현재 main이 인라인으로 동등 기능 처리 중 |

**이 PR에서 현재 main에 적용할 변경사항은 없다.**
