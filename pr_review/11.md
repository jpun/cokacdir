# PR #11 Review — Backend 추상화 레이어 (Claude/Codex)

## 개요

- **변경 파일**: 6개 (신규 3개, 수정 3개)
- **추가된 코드**: ~980줄 (신규 파일), ~40줄 (기존 파일 수정)
- **변경 성격**: AI 백엔드 추상화 trait 도입 + Codex CLI 백엔드 추가 + CLI 플래그 추가
- **PR base와 현재 main 비교**: main이 상당히 진화함 (스케줄링 시스템, 디버그 리팩터링, model 파라미터 등 추가됨). 단순 머지 불가.

---

## 변경 파일 목록

| 파일 | 상태 | 설명 |
|------|------|------|
| `src/services/backend/mod.rs` | **신규** (119줄) | `Backend` trait, `BackendMessage` enum, `CancelToken`, `madmax` 플래그 |
| `src/services/backend/claude.rs` | **신규** (443줄) | Claude CLI를 `Backend` trait으로 래핑 |
| `src/services/backend/codex.rs` | **신규** (418줄) | OpenAI Codex CLI(`omx`/`codex`)를 `Backend` trait으로 래핑 |
| `src/services/mod.rs` | **수정** (+1줄) | `pub mod backend;` 추가 |
| `src/main.rs` | **수정** (~40줄) | `--openclaude`, `--opencodex`, `--madmax` CLI 플래그 추가 |
| `src/services/telegram.rs` | **수정** (+2줄) | 향후 Backend trait 전환 예고 주석만 추가 |

---

## 핵심 변경사항 상세

### 1. `src/services/backend/mod.rs` — 추상화 레이어 정의

#### `BackendMessage` enum
기존 `claude.rs`의 `StreamMessage`와 유사한 역할의 스트리밍 메시지 타입:

```rust
pub enum BackendMessage {
    Init { session_id: String },
    Text(String),
    ToolUse { name: String, input: String },
    ToolResult { content: String, is_error: bool },
    Complete { response: String },
    Error(String),
}
```

#### `Backend` trait
`#[async_trait::async_trait]`으로 async 메서드 지원. `Send + Sync` 필수:

```rust
pub trait Backend: Send + Sync {
    async fn execute_streaming(
        &self, prompt: &str, session_id: Option<&str>, working_dir: &str,
        sender: tokio::sync::mpsc::Sender<BackendMessage>,
        system_prompt: Option<&str>, allowed_tools: Option<&[String]>,
        cancel_token: Option<Arc<CancelToken>>,
    ) -> Result<(), String>;
    fn name(&self) -> &str;
    fn binary_path(&self) -> Option<String>;
    fn default_allowed_tools(&self) -> Vec<String>;
}
```

#### `CancelToken` (새 버전)
기존 `claude::CancelToken`을 개선. 메서드 캡슐화:

```rust
pub struct CancelToken {
    pub cancelled: AtomicBool,
    pub child_pid: Mutex<Option<u32>>,
}
// cancel() — 플래그 설정 + libc::kill(SIGTERM)으로 자식 프로세스 종료
// is_cancelled() — 상태 조회
// set_child_pid() — PID 등록
// Default trait 구현
```

#### `madmax` 글로벌 플래그
```rust
static MADMAX_MODE: AtomicBool = AtomicBool::new(false);
pub fn set_madmax(enabled: bool) { ... }
pub fn is_madmax() -> bool { ... }
```

### 2. `src/services/backend/claude.rs` — Claude 백엔드

기존 `claude.rs`의 스트리밍 실행 로직을 `Backend` trait 구현체로 재작성.

- **바이너리 탐색**: `which claude` → `bash -lc "which claude"` (기존과 동일 로직)
- **DEFAULT_ALLOWED_TOOLS**: 17개 도구 (기존과 동일)
- **DEFAULT_SYSTEM_PROMPT**: 보안 규칙 + Bash 실행 규칙 (기존과 거의 동일하나 Markdown 포매팅 지시 누락)
- **parse_line()**: Claude `stream-json` JSONL 파싱 (기존 `parse_stream_message()`와 유사)
- **execute_streaming()**: `tokio::task::spawn_blocking`으로 동기 I/O를 async로 래핑. 내부 mpsc 채널로 메시지 전달.
- **run_claude_process()**: 동기 워커. `CLAUDE_CODE_MAX_OUTPUT_TOKENS=64000`, `BASH_DEFAULT/MAX_TIMEOUT_MS=86400000` 환경변수 설정.

**권한 처리의 변경:**
```rust
if super::is_madmax() {
    args.push("--dangerously-skip-permissions");
} else {
    args.push("--permission-mode");
    args.push("default");
}
```
기존 코드는 **항상** `--dangerously-skip-permissions`를 사용. PR은 `--madmax` 플래그 없으면 `--permission-mode default`로 변경.

### 3. `src/services/backend/codex.rs` — Codex 백엔드

OpenAI Codex CLI 또는 omx(Oh My Codex) 래퍼를 지원:

- **바이너리 탐색 우선순위**: `omx` > `codex` (각각 `which` → `bash -lc which`)
- **DEFAULT_ALLOWED_TOOLS**: Claude와 동일한 17개 (문제 — 아래 참고)
- **DEFAULT_SYSTEM_PROMPT**: Codex용으로 약간 수정된 프롬프트
- **parse_codex_line()**: Codex JSONL 이벤트 파싱:
  - `"thread.started"` → Init
  - `"item.started"` (command_execution) → ToolUse
  - `"item.completed"` (agent_message → Text, command_execution → ToolResult, error → Error)
  - `"turn.completed"` → Complete
  - `"Under-development features enabled"` 에러 메시지 필터링
- **codex_args()**: `-C <dir> --sandbox danger-full-access -a never exec [resume <sid>] --json -`
- **is_available()**: 바이너리 존재 여부 확인 (static method)
- 시스템 프롬프트를 `SYSTEM:\n...\n\n<prompt>` 형태로 prepend (Codex에는 `--append-system-prompt` 같은 옵션이 없으므로)

### 4. `src/main.rs` 변경

#### help 텍스트 추가
```
--ccserver <TOKEN>...   Start Telegram bot server(s) (alias: --openclaude)
--openclaude <TOKEN>... Start Telegram bot with Claude backend
--opencodex <TOKEN>...  Start Telegram bot with Codex backend (uses omx if available)
--madmax                Skip all AI permission checks (use with caution)
```

#### 인자 파싱 변경

```rust
// 루프 전 pre-scan으로 madmax 글로벌 설정
if args.iter().any(|a| a == "--madmax") {
    services::backend::set_madmax(true);
}

// 루프 내
"--madmax" => { i += 1; continue; }  // 이미 처리됨, skip

"--ccserver" | "--openclaude" => {
    // 기존 --ccserver 로직과 동일, 에러 메시지만 동적으로 변경
    handle_ccserver(tokens);
}

"--opencodex" => {
    // CodexBackend::is_available() 체크 후 실패 시 설치 안내 출력
    // 성공 시 handle_ccserver(tokens) 호출 ← 여기가 문제
}
```

### 5. `src/services/telegram.rs` 변경

주석 2줄만 추가:
```rust
// Future: Replace direct claude:: calls with Backend trait dispatch
// use crate::services::backend::{Backend, ClaudeBackend, CodexBackend};
```
실제 코드 변경 없음. `telegram.rs`는 여전히 `claude::execute_command_streaming()`을 직접 호출.

---

## 기존 코드(claude.rs)와의 중복 분석

PR의 `backend/claude.rs`(443줄)는 기존 `claude.rs`(1312줄)에서 스트리밍 관련 로직을 추출한 것이다. 두 코드가 병렬로 공존하며 상당한 중복이 있다.

### 중복되는 요소

| 요소 | 기존 `claude.rs` | PR `backend/claude.rs` | 동일 여부 |
|------|------------------|------------------------|-----------|
| 바이너리 탐색 | `resolve_claude_path()` | `resolve_claude_binary_path()` | 로직 동일, 이름만 다름 |
| DEFAULT_ALLOWED_TOOLS | 17개 도구 | 17개 도구 | **동일** |
| 시스템 프롬프트 | 보안규칙 + Bash규칙 + Markdown 포매팅 | 보안규칙 + Bash규칙만 | **Markdown 섹션 누락** |
| JSONL 파싱 | `parse_stream_message(&Value)` | `parse_line(&str)` | 유사하나 입력 타입/반환 타입 다름 |
| CancelToken | 기본 struct + `new()` only | 메서드 캡슐화 (`cancel()`, `is_cancelled()` 등) | PR이 개선됨 |
| 프로세스 실행 | `execute_command_streaming()` (동기) | `run_claude_process()` (동기) + async 래퍼 | 유사 구조 |
| 세션 ID 검증 | `is_valid_session_id()` | 없음 (codex.rs에만 있음) | 누락 |

### 중복되지 않는 요소 (기존 claude.rs에만 있음)

- `execute_command()` (비스트리밍 동기 실행)
- `check_claude()` (Claude CLI 설치 확인)
- `check_session_context()` (세션 컨텍스트 조회)
- `extract_context_summary()` (스케줄용 컨텍스트 요약 추출)
- `parse_claude_output()` (JSON 출력 파싱)
- `debug_log()`, `debug_log_to()` (디버그 로깅)
- `DEBUG_ENABLED` (글로벌 디버그 플래그)
- `model` 파라미터 지원
- `no_session_persistence` 파라미터 지원
- `TaskNotification` 스트림 메시지 타입 처리

---

## PR base와 현재 main의 차이 (코드 진화)

PR이 기반한 이전 버전 이후 main에 추가된 기능들:

| 현재 main에 추가된 것 | 영향받는 파일 |
|---|---|
| 스케줄링 시스템 (`--cron`, `--cron-list`, `--cron-remove`, `--cron-update`) | `main.rs`, `telegram.rs` |
| `--currenttime` CLI 명령 | `main.rs` |
| `DEBUG_ENABLED` 글로벌 플래그 + `init_debug_from_env()` | `claude.rs` |
| `debug_log_to()` 헬퍼 (파일별 디버그 로그) | `claude.rs` |
| `execute_command`에 `model` 파라미터 추가 | `claude.rs` |
| `execute_command_streaming`에 `model`, `no_session_persistence` 파라미터 추가 | `claude.rs` |
| `extract_context_summary()` 함수 | `claude.rs` |
| `BotSettings`에 `models`, `debug` 필드 추가 | `telegram.rs` |
| `ChatSession`에 `#[derive(Clone)]` 추가 | `telegram.rs` |
| 스케줄 관련 구조체/함수 ~370줄 추가 | `telegram.rs` |
| `handle_sendfile()` 에러 출력 JSON 형식으로 변경 | `main.rs` |
| `--ismcptool`, `--addmcptool` CLI 명령 **제거** | `main.rs` |
| `ai_screen.rs` 디버그 로깅 리팩터링 | `ai_screen.rs` |

---

## 치명적 문제점

### 1. Codex 백엔드가 실제로 작동하지 않음

`--opencodex`로 실행해도 결국 `handle_ccserver(tokens)`를 호출하고, 이것은 `telegram::run_bot()`을 호출하며, `run_bot()` 내부에서는 `claude::execute_command_streaming()`을 직접 호출한다.

```
--opencodex → handle_ccserver() → telegram::run_bot() → claude::execute_command_streaming()
```

`CodexBackend`를 실제로 사용하는 코드 경로가 **어디에도 없다**. `telegram.rs`는 Backend trait으로 전환되지 않았고, 주석만 남아있다. 따라서 `--opencodex`를 써도 **Claude가 실행된다**.

### 2. --openclaude도 기존 --ccserver와 동작이 완전히 동일

`--openclaude`는 `--ccserver`의 alias일 뿐이다. 별도 Backend dispatch가 없으므로 이름만 다르고 동작은 같다.

### 3. `BackendMessage`와 `StreamMessage`의 이원화

기존 `claude.rs`의 `StreamMessage`:
```rust
pub enum StreamMessage {
    Init { session_id },
    Text { content },
    ToolUse { name, input },
    ToolResult { content, is_error },
    Done { result, session_id },           // ← session_id 포함
    Error { message, stdout, stderr, exit_code }, // ← 구조화된 에러
    TaskNotification { task_id, status, summary }, // ← 작업 알림
}
```

PR의 `BackendMessage`:
```rust
pub enum BackendMessage {
    Init { session_id },
    Text(String),
    ToolUse { name, input },
    ToolResult { content, is_error },
    Complete { response },                // ← session_id 없음
    Error(String),                        // ← 단순 문자열
    // TaskNotification 없음
}
```

**손실된 정보:**
- `Complete`에서 `session_id` 없음 → 세션 이어받기 불가능
- `Error`에서 `stdout`, `stderr`, `exit_code` 없음 → 디버깅 정보 손실
- `TaskNotification` 미지원 → 작업 알림 이벤트 무시됨

### 4. `CancelToken` 이중 정의

`claude::CancelToken`과 `backend::CancelToken`이 동시에 존재. 이름은 같지만 다른 struct:
- `claude::CancelToken` — `new()`만 있는 기본 struct. `telegram.rs`가 현재 사용 중.
- `backend::CancelToken` — 메서드가 캡슐화된 개선 버전. 사용하는 곳 없음.

통합하지 않으면 혼란과 유지보수 부담이 생긴다.

---

## 중요 문제점

### 5. 시스템 프롬프트에서 Markdown 포매팅 지시 누락

기존 `claude.rs`의 시스템 프롬프트에는 다음 섹션이 포함되어 있다:

```
IMPORTANT: Format your responses using Markdown for better readability:
- Use **bold** for important terms or commands
- Use `code` for file paths, commands, and technical terms
- Use bullet lists (- item) for multiple items
- Use numbered lists (1. item) for sequential steps
- Use code blocks (```language) for multi-line code or command examples
- Use headers (## Title) to organize longer responses
- Keep formatting minimal and terminal-friendly
```

PR의 `backend/claude.rs`에서 `DEFAULT_SYSTEM_PROMPT` const에는 이 섹션이 **빠져있다**. 만약 향후 이 백엔드가 실제로 사용되면 AI 응답의 포매팅 품질이 저하된다.

### 6. Codex의 DEFAULT_ALLOWED_TOOLS가 Claude 것을 그대로 복사

`codex.rs`의 `DEFAULT_ALLOWED_TOOLS`가 Claude의 것과 동일한 17개:
```rust
"Bash", "Read", "Edit", "Write", "Glob", "Grep", "Task", "TaskOutput",
"TaskStop", "WebFetch", "WebSearch", "NotebookEdit", "Skill",
"TaskCreate", "TaskGet", "TaskUpdate", "TaskList",
```

`Skill`, `NotebookEdit`, `WebSearch`, `WebFetch` 등은 Claude Code 전용 도구 이름이다. Codex CLI는 다른 도구 체계를 사용하므로 이 목록은 부정확하다. 단, 현재 codex_args()에서 이 tools 목록을 실제로 CLI 인자로 전달하지 않으므로 (`_allowed_tools`로 무시됨) 당장 에러가 나지는 않는다.

### 7. 권한 모델 변경 — 기존 동작과 비호환

기존 코드: **항상** `--dangerously-skip-permissions` 사용
PR 코드: `--madmax` 없으면 `--permission-mode default` 사용

이것은 보안 개선이지만, 기존 사용자의 동작이 바뀌는 **breaking change**이다. `--madmax` 없이 서버를 시작하면 Claude CLI가 도구 실행 전 권한을 묻게 되어, headless 텔레그램 봇 환경에서 봇이 멈출 수 있다.

### 8. 세션 ID 검증 누락 (backend/claude.rs)

기존 `claude.rs`에는 `is_valid_session_id()` 함수가 있어 세션 ID 형식을 검증한다 (영숫자 + 하이픈 + 언더스코어, 최대 64자). `backend/claude.rs`의 `execute_streaming()`에서는 `session_id`를 검증 없이 그대로 `--resume` 인자로 전달한다. `codex.rs`에는 `is_valid_session_id()`가 있어 검증한다 — claude.rs에만 빠진 것.

---

## 경미한 문제점 / 참고사항

### 9. tool_use input 포매팅 차이

기존 `parse_stream_message()`는 tool input을 `serde_json::to_string_pretty()`로 포매팅.
PR의 `parse_line()`은 `as_str()` → `serde_json::to_string()`으로 compact JSON 사용.
UI에서 tool input 표시 형태가 달라진다.

### 10. Cargo.toml 변경 없음

PR의 before/after Cargo.toml이 동일하다. `async-trait`은 현재 main에 이미 `async-trait = "0.1"`로 존재하므로 추가 의존성이 필요하지 않다.

### 11. `Ordering::Relaxed` 사용

`MADMAX_MODE`의 atomic 연산에 `Ordering::Relaxed`를 사용. 이 플래그는 프로그램 시작 시 한 번 설정되고 이후 읽기만 하므로 실질적 문제는 없지만, `Ordering::Release`/`Ordering::Acquire` 쌍이 더 정확하다.

### 12. `#[cfg(unix)]`로 감싼 SIGTERM

`CancelToken::cancel()`의 `libc::kill()` 호출이 `#[cfg(unix)]`로 감싸져 있어 Windows에서는 자식 프로세스를 종료하지 못한다. 현재 프로젝트가 Linux/macOS 대상이므로 당장 문제는 아니나, cross-platform 고려 시 Windows 대응 필요.

---

## 적용 가능성 분석

### 현재 main에 직접 머지 가능한 부분

| 항목 | 난이도 | 비고 |
|------|--------|------|
| `src/services/backend/` 디렉토리 3개 파일 복사 | **쉬움** | 신규 파일, 충돌 없음 |
| `src/services/mod.rs`에 `pub mod backend;` 추가 | **쉬움** | 1줄 추가 |
| `Cargo.toml` | **불필요** | `async-trait` 이미 존재 |

### 수동 적용 필요한 부분

| 항목 | 난이도 | 비고 |
|------|--------|------|
| `main.rs` help 텍스트 | **중간** | 현재 main은 cron 관련 도움말이 추가됨. PR의 help 변경을 현재 구조에 맞게 재작성 필요 |
| `main.rs` 인자 파싱 | **중간** | `--madmax` pre-scan, `--openclaude`/`--opencodex` 분기 추가. 현재 main의 cron 관련 인자 파싱과 위치 조정 필요 |
| `telegram.rs` | **불필요** | 주석 2줄뿐이며 실질 의미 없음 |

### 적용 후에도 남는 근본 문제

적용하더라도 `--opencodex`를 실행하면 여전히 Claude가 실행된다. `telegram.rs`에서 Backend trait dispatch를 구현하지 않는 한, 이 PR의 backend 추상화는 사실상 **dead code**이다. 의미있는 Codex 지원을 위해서는 최소한 다음이 추가로 필요하다:

1. `handle_ccserver()`가 어떤 Backend를 사용할지 인자로 받는 구조로 변경
2. `telegram::run_bot()`이 `Backend` trait 객체를 받아 사용하도록 리팩터링
3. `StreamMessage` → `BackendMessage` 통합 또는 변환 레이어
4. `CancelToken` 이중 정의 해소

---

## 종합 평가

### 긍정적인 면

- **설계 방향은 올바름**: Backend trait 추상화를 통해 다양한 AI CLI 도구를 플러그인처럼 지원하겠다는 아키텍처는 좋은 방향
- **CancelToken 개선**: 메서드 캡슐화로 기존의 raw field 접근보다 안전하고 깔끔
- **Codex CLI 파싱 구현 완성도**: `parse_codex_line()`의 이벤트 매핑이 Codex CLI의 실제 JSONL 형식에 맞게 잘 작성됨
- **시스템 프롬프트 const 추출**: 기존 코드에서 인라인으로 두 번 중복되던 시스템 프롬프트를 const로 추출한 것은 개선

### 부정적인 면

- **핵심 기능 미완성**: Backend trait을 만들어 놓고 실제로 사용하는 코드가 없음. `--opencodex`가 Codex를 실행하지 않음
- **기존 코드와 대량 중복**: `backend/claude.rs`의 상당 부분이 기존 `claude.rs`와 중복되며, 기존 코드를 대체하지도 않음
- **정보 손실**: `BackendMessage`가 `StreamMessage` 대비 `session_id`, 구조화된 에러, `TaskNotification`을 지원하지 않음
- **breaking change**: 권한 모델이 기본값으로 `--permission-mode default`로 바뀌어 headless 봇 환경에서 문제 발생 가능
- **시스템 프롬프트 회귀**: Markdown 포매팅 지시 누락

### 결론

이 PR은 **"Codex 백엔드 지원을 위한 추상화 골격"**만 제공하며, 실제 Codex 지원은 되지 않는 미완성 상태이다. `--opencodex`를 실행해도 Claude가 실행되고, ~980줄의 신규 코드 중 실제로 호출되는 것은 `set_madmax()` 정도뿐이다. 적용할 경우 **dead code**가 대량 추가되는 셈이며, 완성까지의 후속 작업 범위가 크다 (telegram.rs 전면 리팩터링 필요). 현 상태로의 머지는 권장하지 않으며, Backend trait 통합이 telegram.rs까지 완료된 후 다시 리뷰하는 것이 바람직하다.
