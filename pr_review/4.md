# Discord Bot + Web UI 통합 — 적용 매뉴얼

이 문서는 `./prdiff/` 에 담긴 PR 변경사항을 현재 메인 프로젝트(`./`)에 적용하기 위한 실행 매뉴얼이다.

## 배경

- PR 작성자의 작업 기반: `./prdiff/before/` (v0.4.36)
- PR 작성자의 결과물: `./prdiff/after/`
- 현재 메인 프로젝트: `./` (v0.4.39)
- 메인 프로젝트는 PR 기반 이후 cron/schedule 시스템, 디버그 시스템 개편, model/session 파라미터 확장 등이 추가된 상태

## 적용할 것 요약

| 항목 | 설명 |
|------|------|
| `./src/services/discord.rs` (신규, 2332줄) | Discord 봇 서버 (poise + serenity 기반) |
| `./src/services/webui.rs` (신규, 516줄) | Axum 기반 Web UI 서버 (WebSocket 실시간 업데이트) |
| `./webui-src/` (신규 디렉토리) | Web UI 프론트엔드 소스 (React/TypeScript/Vite) |
| `./webui-dist/` (신규 디렉토리) | Web UI 빌드 산출물 (HTML/JS/CSS + 에셋) |
| `./Cargo.toml` 의존성 5개 추가 | serenity, poise, axum, tower-http, include_dir |
| CLI 인자 3개 추가 | `--dcserver`, `--webui`, `--discord-sendfile` |
| `StreamMessage::StatusUpdate` variant 추가 | 모델명, 비용, 토큰 사용량 실시간 추적 |
| `SessionData` struct에 discord 필드 3개 추가 | discord_channel_id, discord_channel_name, discord_category_name |
| `format_tool_input` → `pub` 변경 | discord.rs에서 telegram.rs의 함수를 참조하기 위함 |

---

## 1단계: `./Cargo.toml` — 의존성 추가

**수정 대상**: `./Cargo.toml` line 44

현재 line 44:
```toml
reqwest = { version = "0.12", default-features = false, features = ["rustls-tls"] }
```

이 줄 다음에 5줄 추가:
```toml
serenity = { version = "0.12", default-features = false, features = ["client", "gateway", "model", "rustls_backend", "cache"] }
poise = { version = "0.6" }
axum = { version = "0.8", features = ["ws"] }
tower-http = { version = "0.6", features = ["fs", "cors"] }
include_dir = "0.7"
```

---

## 2단계: `./src/services/mod.rs` — 모듈 선언 추가

**수정 대상**: `./src/services/mod.rs`

현재 전체 내용 (7줄):
```rust
pub mod file_ops;
pub mod process;
pub mod claude;
pub mod remote;
pub mod remote_transfer;
pub mod dedup;
pub mod telegram;
```

마지막 줄 뒤에 2줄 추가하여 최종:
```rust
pub mod file_ops;
pub mod process;
pub mod claude;
pub mod remote;
pub mod remote_transfer;
pub mod dedup;
pub mod telegram;
pub mod discord;
pub mod webui;
```

---

## 3단계: `./src/services/claude.rs` — StreamMessage enum 확장

**수정 대상**: `./src/services/claude.rs` line 108~123

현재 상태 (line 120~123):
```rust
    /// Error
    Error { message: String, stdout: String, stderr: String, exit_code: Option<i32> },
}
```

`Error` variant와 닫는 `}` 사이에 새 variant 삽입:
```rust
    /// Error
    Error { message: String, stdout: String, stderr: String, exit_code: Option<i32> },
    /// Statusline info extracted from result/assistant events
    StatusUpdate {
        model: Option<String>,
        cost_usd: Option<f64>,
        total_cost_usd: Option<f64>,
        duration_ms: Option<u64>,
        num_turns: Option<u32>,
        input_tokens: Option<u64>,
        output_tokens: Option<u64>,
    },
}
```

---

## 4단계: `./src/services/claude.rs` — execute_command_streaming 내부 수정 (4곳)

모두 `./src/services/claude.rs`의 `execute_command_streaming` 함수 내부이다.

### 4-A: 추적 변수 3개 선언 추가

**위치**: line 758

현재:
```rust
    let mut last_session_id: Option<String> = None;
    let mut final_result: Option<String> = None;
```

변경 (사이에 3줄 삽입):
```rust
    let mut last_session_id: Option<String> = None;
    let mut last_model: Option<String> = None;
    let mut accum_input_tokens: u64 = 0;
    let mut accum_output_tokens: u64 = 0;
    let mut final_result: Option<String> = None;
```

### 4-B: assistant 메시지에서 모델/토큰 정보 추출

**위치**: line 808~812

현재:
```rust
            if msg_type == "assistant" {
                if let Some(content) = json.get("message").and_then(|m| m.get("content")) {
                    debug_log(&format!("  Assistant content array: {}", content));
                }
            }
```

변경 (블록 안에 코드 추가):
```rust
            if msg_type == "assistant" {
                if let Some(content) = json.get("message").and_then(|m| m.get("content")) {
                    debug_log(&format!("  Assistant content array: {}", content));
                }
                // Extract model name and token usage from assistant messages
                if let Some(msg_obj) = json.get("message") {
                    if let Some(model) = msg_obj.get("model").and_then(|v| v.as_str()) {
                        last_model = Some(model.to_string());
                    }
                    if let Some(usage) = msg_obj.get("usage") {
                        if let Some(inp) = usage.get("input_tokens").and_then(|v| v.as_u64()) {
                            accum_input_tokens += inp;
                        }
                        if let Some(out) = usage.get("output_tokens").and_then(|v| v.as_u64()) {
                            accum_output_tokens += out;
                        }
                    }
                }
            }
```

### 4-C: result 이벤트에서 StatusUpdate 전송

**위치**: line 812 (4-B의 `}` 닫는 줄) 과 line 814 (`debug_log("  Calling parse_stream_message...");`) 사이

현재:
```rust
            }

            debug_log("  Calling parse_stream_message...");
```

변경 (사이에 블록 삽입):
```rust
            }

            // Extract statusline info from result events
            if msg_type == "result" {
                let cost_usd = json.get("cost_usd").and_then(|v| v.as_f64());
                let total_cost_usd = json.get("total_cost_usd").and_then(|v| v.as_f64());
                let duration_ms = json.get("duration_ms").and_then(|v| v.as_u64());
                let num_turns = json.get("num_turns").and_then(|v| v.as_u64()).map(|v| v as u32);
                if cost_usd.is_some() || total_cost_usd.is_some() || last_model.is_some() {
                    let _ = sender.send(StreamMessage::StatusUpdate {
                        model: last_model.clone(),
                        cost_usd,
                        total_cost_usd,
                        duration_ms,
                        num_turns,
                        input_tokens: if accum_input_tokens > 0 { Some(accum_input_tokens) } else { None },
                        output_tokens: if accum_output_tokens > 0 { Some(accum_output_tokens) } else { None },
                    });
                }
            }

            debug_log("  Calling parse_stream_message...");
```

### 4-D: match 블록에 StatusUpdate 디버그 로깅 arm 추가

**위치**: line 851~854 (match 블록 내 `TaskNotification` arm 뒤)

현재:
```rust
                    StreamMessage::TaskNotification { task_id, status, summary } => {
                        debug_log(&format!("  >>> TaskNotification: task_id={}, status={}, summary={}", task_id, status, summary));
                    }
                }
```

변경 (`TaskNotification` arm 뒤, `}` 닫기 전에 arm 추가):
```rust
                    StreamMessage::TaskNotification { task_id, status, summary } => {
                        debug_log(&format!("  >>> TaskNotification: task_id={}, status={}, summary={}", task_id, status, summary));
                    }
                    StreamMessage::StatusUpdate { ref model, cost_usd, total_cost_usd, .. } => {
                        debug_log(&format!("  >>> StatusUpdate: model={:?}, cost={:?}, total_cost={:?}", model, cost_usd, total_cost_usd));
                    }
                }
```

---

## 5단계: `./src/ui/ai_screen.rs` — 2곳 수정

### 5-A: SessionData struct에 discord 필드 추가

**위치**: line 374~380

현재:
```rust
pub struct SessionData {
    pub session_id: String,
    pub history: Vec<HistoryItem>,
    pub current_path: String,
    pub created_at: String,
}
```

변경:
```rust
pub struct SessionData {
    pub session_id: String,
    pub history: Vec<HistoryItem>,
    pub current_path: String,
    pub created_at: String,
    /// Discord channel ID (optional, set by Discord bot)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discord_channel_id: Option<u64>,
    /// Discord channel name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discord_channel_name: Option<String>,
    /// Discord parent category name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discord_category_name: Option<String>,
}
```

`#[serde(default)]`로 인해 기존 JSON 파일과의 역호환 보장 — 기존 세션 파일 로드 시 이 필드들은 `None`이 된다.

### 5-B: StreamMessage match 블록에 StatusUpdate arm 추가

**위치**: line 1007 부근 (match 블록의 마지막 arm인 `StreamMessage::Error`)

현재 match 블록에 있는 arm들 (line 954~):
- `StreamMessage::Init`
- `StreamMessage::Text`
- `StreamMessage::ToolUse`
- `StreamMessage::ToolResult`
- `StreamMessage::TaskNotification`
- `StreamMessage::Done`
- `StreamMessage::Error` ← 현재 마지막

`Error` arm 닫는 `}` 바로 뒤에 추가:
```rust
                StreamMessage::StatusUpdate { .. } => {
                    // Ignored in TUI (only used for webui statusline)
                }
```

---

## 6단계: `./src/services/telegram.rs` — 4곳 수정

### 6-A: `format_tool_input` 함수를 pub으로 변경

**위치**: line 3433

현재:
```rust
fn format_tool_input(name: &str, input: &str) -> String {
```

변경:
```rust
pub fn format_tool_input(name: &str, input: &str) -> String {
```

이유: `./src/services/discord.rs`에서 `telegram::format_tool_input(&name, &input)`로 호출한다.

### 6-B: 첫 번째 StreamMessage match 블록에 StatusUpdate arm 추가

**위치**: line 2559~2572 (일반 채팅의 StreamMessage match)

현재 이 match의 마지막 arm:
```rust
                                StreamMessage::Error { message, stdout, stderr, exit_code } => {
                                    ...
                                    done = true;
                                }
```

이 `Error` arm 닫는 `}` 뒤에 추가:
```rust
                                StreamMessage::StatusUpdate { .. } => {
                                    // Ignored in telegram (only used for webui statusline)
                                }
```

### 6-C: 두 번째 StreamMessage match 블록에 StatusUpdate arm 추가

**위치**: line 3916~3929 (schedule 실행의 StreamMessage match)

동일하게 `Error` arm 닫는 `}` 뒤에 추가:
```rust
                            StreamMessage::StatusUpdate { .. } => {
                                // Ignored in telegram (only used for webui statusline)
                            }
```

### 6-D: SessionData 생성 부분에 discord 필드 초기화 추가

**위치**: line 2889~2894

현재:
```rust
    let session_data = SessionData {
        session_id: session_id.clone(),
        history: saveable_history,
        current_path: current_path.to_string(),
        created_at: chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string(),
    };
```

변경:
```rust
    let session_data = SessionData {
        session_id: session_id.clone(),
        history: saveable_history,
        current_path: current_path.to_string(),
        created_at: chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string(),
        discord_channel_id: None,
        discord_channel_name: None,
        discord_category_name: None,
    };
```

---

## 7단계: `./src/main.rs` — 핸들러 함수 3개 + match arm 3개 + help 텍스트

### 7-A: help 텍스트에 Discord/WebUI 항목 추가

**위치**: line 43~46

현재 (line 43~46):
```rust
    println!("    --ccserver <TOKEN>...   Start Telegram bot server(s)");
    println!("    --sendfile <PATH> --chat <ID> --key <HASH>");
    println!("                            Send file via Telegram bot (internal use, HASH = token hash)");
    println!("    --currenttime            Print current server time");
```

변경 (`--sendfile` 설명 뒤, `--currenttime` 앞에 삽입):
```rust
    println!("    --ccserver <TOKEN>...   Start Telegram bot server(s)");
    println!("    --sendfile <PATH> --chat <ID> --key <HASH>");
    println!("                            Send file via Telegram bot (internal use, HASH = token hash)");
    println!("    --dcserver <TOKEN> [--webui PORT]");
    println!("                            Start Discord bot server (optionally with web UI)");
    println!("    --discord-sendfile <PATH> --channel <ID> --key <HASH>");
    println!("                            Send file via Discord bot (internal use, HASH = token hash)");
    println!("    --webui [PORT]          Start web UI server (default port: 3333)");
    println!("    --currenttime            Print current server time");
```

### 7-B: 핸들러 함수 3개 추가

**위치**: `fn handle_ccserver` 함수 직전 (line 453 부근) — 다른 핸들러 함수들이 모여 있는 영역

아래 3개 함수를 추가:

```rust
fn handle_webui(port: u16) {
    let rt = tokio::runtime::Runtime::new().expect("Failed to create Tokio runtime");

    let title = format!("  cokacdir v{}  |  Web UI Server  ", VERSION);
    let width = title.chars().count();
    println!();
    println!("  ┌{}┐", "─".repeat(width));
    println!("  │{}│", title);
    println!("  └{}┘", "─".repeat(width));
    println!();
    rt.block_on(services::webui::run_webui(port));
}

fn handle_dcserver(token: String, webui_port: Option<u16>) {
    let rt = tokio::runtime::Runtime::new().expect("Failed to create Tokio runtime");

    let title = format!("  cokacdir v{}  |  Discord Bot Server  ", VERSION);
    let width = title.chars().count();
    println!();
    println!("  ┌{}┐", "─".repeat(width));
    println!("  │{}│", title);
    println!("  └{}┘", "─".repeat(width));
    println!();
    println!("  ▸ Status : Connecting...");

    rt.block_on(async {
        if let Some(port) = webui_port {
            tokio::spawn(services::webui::run_webui(port));
        }
        println!();
        services::discord::run_bot(&token).await;
    });
}

fn handle_discord_sendfile(path: &str, channel_id: u64, hash_key: &str) {
    use crate::services::discord::resolve_discord_token_by_hash;
    let token = match resolve_discord_token_by_hash(hash_key) {
        Some(t) => t,
        None => {
            eprintln!("Error: no Discord bot token found for hash key: {}", hash_key);
            std::process::exit(1);
        }
    };
    let rt = tokio::runtime::Runtime::new().expect("Failed to create Tokio runtime");
    rt.block_on(async {
        match services::discord::send_file_to_channel(&token, channel_id, path).await {
            Ok(_) => println!("File sent: {}", path),
            Err(e) => {
                eprintln!("Failed to send file: {}", e);
                std::process::exit(1);
            }
        }
    });
}
```

### 7-C: main()의 match 블록에 3개 arm 추가

**위치**: `"--ccserver"` arm (line 565~577)과 `"--currenttime"` arm (line 578) 사이

아래 3개 arm을 삽입:

```rust
            "--webui" => {
                let port = if i + 1 < args.len() && !args[i + 1].starts_with('-') {
                    args[i + 1].parse::<u16>().unwrap_or(3333)
                } else {
                    3333
                };
                handle_webui(port);
                return Ok(());
            }
            "--dcserver" => {
                if i + 1 >= args.len() {
                    eprintln!("Error: --dcserver requires a token argument");
                    eprintln!("Usage: cokacdir --dcserver <TOKEN> [--webui PORT]");
                    return Ok(());
                }
                let token = args[i + 1].clone();
                let webui_port = args.iter().position(|a| a == "--webui").and_then(|idx| {
                    if idx + 1 < args.len() && !args[idx + 1].starts_with('-') {
                        args[idx + 1].parse::<u16>().ok()
                    } else {
                        Some(3333)
                    }
                });
                handle_dcserver(token, webui_port);
                return Ok(());
            }
            "--discord-sendfile" => {
                let mut file_path: Option<String> = None;
                let mut channel_id: Option<u64> = None;
                let mut key: Option<String> = None;
                let mut j = i + 1;
                while j < args.len() {
                    match args[j].as_str() {
                        "--channel" => {
                            if j + 1 < args.len() {
                                channel_id = args[j + 1].parse().ok();
                                j += 2;
                            } else {
                                j += 1;
                            }
                        }
                        "--key" => {
                            if j + 1 < args.len() {
                                key = Some(args[j + 1].clone());
                                j += 2;
                            } else {
                                j += 1;
                            }
                        }
                        _ if file_path.is_none() && !args[j].starts_with("--") => {
                            file_path = Some(args[j].clone());
                            j += 1;
                        }
                        _ => { j += 1; }
                    }
                }
                match (file_path, channel_id, key) {
                    (Some(fp), Some(cid), Some(k)) => {
                        handle_discord_sendfile(&fp, cid, &k);
                    }
                    _ => {
                        eprintln!("Error: --discord-sendfile requires <PATH>, --channel <ID>, and --key <HASH>");
                        eprintln!("Usage: cokacdir --discord-sendfile <PATH> --channel <ID> --key <HASH>");
                    }
                }
                return Ok(());
            }
```

---

## 8단계: `./src/services/discord.rs` — 신규 파일 생성

**복사 원본**: `./prdiff/after/src/services/discord.rs`
**생성 위치**: `./src/services/discord.rs`

복사 후 **1곳 반드시 수정**:

### discord.rs line 1415~1423 — execute_command_streaming 호출 시그니처

복사된 원본 (7개 인자):
```rust
        let result = claude::execute_command_streaming(
            &context_prompt,
            session_id_clone.as_deref(),
            &current_path_clone,
            tx.clone(),
            Some(&system_prompt_owned),
            Some(&allowed_tools),
            Some(cancel_token_clone),
        );
```

변경 (9개 인자 — 마지막 2개 추가):
```rust
        let result = claude::execute_command_streaming(
            &context_prompt,
            session_id_clone.as_deref(),
            &current_path_clone,
            tx.clone(),
            Some(&system_prompt_owned),
            Some(&allowed_tools),
            Some(cancel_token_clone),
            None,   // model
            false,  // no_session_persistence
        );
```

이유: 현재 메인 프로젝트의 `execute_command_streaming`은 `model: Option<&str>`과 `no_session_persistence: bool` 파라미터가 추가되었다 (`./src/services/claude.rs` line 598~607).

이 호출은 discord.rs 전체에서 **1곳**뿐이다.

### discord.rs가 참조하는 외부 심볼 (모두 현재 메인 프로젝트에 존재 확인됨)

| 참조 | 위치 | 현재 메인 프로젝트 존재 여부 |
|------|------|--------------------------|
| `claude::{CancelToken, StreamMessage, DEFAULT_ALLOWED_TOOLS}` | line 17 | ✅ `./src/services/claude.rs` |
| `ai_screen::{HistoryItem, HistoryType, SessionData}` | line 18 | ✅ `./src/ui/ai_screen.rs` |
| `ai_screen::sanitize_user_input()` | line 1332 | ✅ `./src/ui/ai_screen.rs` line 46 |
| `ai_screen::ai_sessions_dir()` | line 1944, 2020, 2086 | ✅ `./src/ui/ai_screen.rs` line 383 |
| `telegram::format_tool_input()` | line 1473 | ✅ 6-A 단계에서 pub으로 변경 |
| `webui::push_status_by_session()` | line 1403, 1597 | ✅ 9단계에서 생성 |
| `webui::push_statusline_by_session()` | line 1518 | ✅ 9단계에서 생성 |

discord.rs 내부에 자체 정의된 헬퍼 (외부 의존 없음):
- `truncate_str()` (line 2160)
- `normalize_empty_lines()` (line 2174)
- `floor_char_boundary()` (line 2147)

### discord.rs가 외부에 노출하는 pub 함수 (main.rs에서 호출)

```rust
pub async fn run_bot(token: &str)                                                    // line 358
pub fn resolve_discord_token_by_hash(hash: &str) -> Option<String>                  // line 168
pub async fn send_file_to_channel(token: &str, channel_id: u64, file_path: &str) -> Result<(), String>  // line 1868
```

---

## 9단계: `./src/services/webui.rs` — 신규 파일 생성

**복사 원본**: `./prdiff/after/src/services/webui.rs`
**생성 위치**: `./src/services/webui.rs`

**수정 필요 없음** — 그대로 복사.

webui.rs가 참조하는 외부 심볼 (모두 현재 메인 프로젝트에 존재 확인됨):

| 참조 | 위치 | 현재 메인 프로젝트 존재 여부 |
|------|------|--------------------------|
| `ai_screen::ai_sessions_dir()` | line 172 | ✅ `./src/ui/ai_screen.rs` line 383 |
| `ai_screen::SessionData` | line 305 | ✅ 5-A 단계에서 discord 필드 추가 완료 |
| `ai_screen::HistoryType::{User, Assistant, ToolUse}` | line 314~321 | ✅ `./src/ui/ai_screen.rs` line 322~329 |
| `SessionData.discord_channel_name` | line 331 | ✅ 5-A 단계에서 추가 |
| `SessionData.discord_category_name` | line 332 | ✅ 5-A 단계에서 추가 |

webui.rs가 외부에 노출하는 pub 함수 (discord.rs, main.rs에서 호출):

```rust
pub async fn run_webui(port: u16)                          // line 171 — main.rs에서 호출
pub fn push_status_by_session(session_id: &str, status: &str)  // line 24 — discord.rs에서 호출
pub fn push_statusline_by_session(...)                     // line 47 — discord.rs에서 호출
```

---

## 10단계: `./webui-dist/` 및 `./webui-src/` — 신규 디렉토리 복사

```
./prdiff/after/webui-dist/  →  ./webui-dist/
./prdiff/after/webui-src/   →  ./webui-src/
```

충돌 없음 — 두 디렉토리 모두 현재 메인 프로젝트에 존재하지 않는다.

### webui-dist/ 내용물
- `index.html` — Web UI 엔트리 포인트
- `assets/index-BjJCMdXA.js`, `assets/index-CDgABIYG.css` — 빌드된 번들
- `assets/characters/` — 캐릭터 스프라이트 PNG
- `assets/items/` — 가구 스프라이트 PNG
- `assets/*.png` — 타일셋, 벽, 바닥 이미지
- `assets/default-layout.json` — 오피스 레이아웃 설정
- `assets/FSPixelSansUnicode-Regular-*.ttf` — 폰트

### webui-src/ 내용물
- React + TypeScript + Vite 프로젝트
- `src/office/` — 2D 오피스 렌더링 엔진 (캔버스 기반)
- `src/components/` — UI 컴포넌트
- `src/hooks/` — React 훅

---

## 11단계: `./dist/cokacdir-macos-arm64` — 신규 바이너리 복사

```
./prdiff/after/dist/cokacdir-macos-arm64  →  ./dist/cokacdir-macos-arm64
```

---

## 검증 체크리스트

적용 완료 후 빌드 전에 확인:

### 신규 파일 존재 여부
- [ ] `./src/services/discord.rs` 존재
- [ ] `./src/services/webui.rs` 존재
- [ ] `./webui-dist/index.html` 존재
- [ ] `./webui-src/package.json` 존재
- [ ] `./dist/cokacdir-macos-arm64` 존재

### `./Cargo.toml`
- [ ] `serenity`, `poise`, `axum`, `tower-http`, `include_dir` 5개 의존성이 `[dependencies]` 섹션에 존재

### `./src/services/mod.rs`
- [ ] `pub mod discord;` 존재
- [ ] `pub mod webui;` 존재

### `./src/services/claude.rs`
- [ ] `StreamMessage` enum에 `StatusUpdate { model, cost_usd, total_cost_usd, duration_ms, num_turns, input_tokens, output_tokens }` variant 존재
- [ ] `execute_command_streaming` 안에 `let mut last_model: Option<String> = None;` 존재
- [ ] `execute_command_streaming` 안에 `let mut accum_input_tokens: u64 = 0;` 존재
- [ ] `execute_command_streaming` 안에 `let mut accum_output_tokens: u64 = 0;` 존재
- [ ] `if msg_type == "assistant"` 블록 안에 `msg_obj.get("model")` 코드 존재
- [ ] `if msg_type == "result"` 블록에서 `sender.send(StreamMessage::StatusUpdate { ... })` 존재
- [ ] match 블록에 `StreamMessage::StatusUpdate { ref model, cost_usd, total_cost_usd, .. }` arm 존재

### `./src/ui/ai_screen.rs`
- [ ] `SessionData` struct에 `pub discord_channel_id: Option<u64>` 존재
- [ ] `SessionData` struct에 `pub discord_channel_name: Option<String>` 존재
- [ ] `SessionData` struct에 `pub discord_category_name: Option<String>` 존재
- [ ] 세 필드 모두 `#[serde(default, skip_serializing_if = "Option::is_none")]` 있음
- [ ] StreamMessage match 블록에 `StreamMessage::StatusUpdate { .. } => {}` arm 존재

### `./src/services/telegram.rs`
- [ ] `pub fn format_tool_input(name: &str, input: &str) -> String {` (pub 확인)
- [ ] 첫 번째 StreamMessage match (line 2496 부근)에 `StatusUpdate { .. }` arm 존재
- [ ] 두 번째 StreamMessage match (line 3855 부근)에 `StatusUpdate { .. }` arm 존재
- [ ] `SessionData { ... }` 생성 부분 (line 2889 부근)에 `discord_channel_id: None` 존재

### `./src/main.rs`
- [ ] `fn handle_webui(port: u16)` 함수 존재
- [ ] `fn handle_dcserver(token: String, webui_port: Option<u16>)` 함수 존재
- [ ] `fn handle_discord_sendfile(path: &str, channel_id: u64, hash_key: &str)` 함수 존재
- [ ] match 블록에 `"--webui"` arm 존재
- [ ] match 블록에 `"--dcserver"` arm 존재
- [ ] match 블록에 `"--discord-sendfile"` arm 존재
- [ ] `print_help()`에 `--dcserver`, `--discord-sendfile`, `--webui` 설명 존재

### `./src/services/discord.rs` (복사 후 수정 확인)
- [ ] line 1415 부근 `execute_command_streaming` 호출이 9개 인자 (마지막 `None, false`)
