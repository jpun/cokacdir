# PR #6 Review: 텔레그램 봇 권한(Auth) 시스템 추가

## 개요

- **변경 파일**: 3개 (`src/services/auth.rs` 신규, `src/services/mod.rs` 수정, `src/services/telegram.rs` 수정)
- **변경 성격**: 텔레그램 봇에 명령어 레벨의 접근 제어(Access Control) 시스템 추가
- **PR base와 현재 main 비교**: 1717줄의 diff 존재 (스케줄링, models/debug 필드 등 main에 추가된 기능 다수)
- **충돌 위험**: 낮음. PR의 모든 변경이 순수 삽입(insertion)이며 기존 코드를 수정하지 않음
- **적용 가능 여부**: 적용 가능. PR이 참조하는 모든 변수/타입이 현재 main에 존재함

---

## PR의 목적

텔레그램 봇의 **명시적 명령어(`/`, `!`)에 대한 기능별 권한 부여 및 범위 설정**이 핵심이다.

3가지 보안 레이어를 추가한다:

1. **Command Risk Classification** — 명령어를 Safe/Elevated/Dangerous 3단계로 분류
2. **Permission Check** — 사용자 유형(Owner/Public 비소유자/일반 비소유자)에 따라 실행 허용 범위 제한
3. **Sandbox Check** — `/start`, `/down` 명령에서 홈 디렉토리 밖 경로 접근 차단

---

## 변경 파일 상세

### 1. 신규 파일: `src/services/auth.rs` (149줄)

완전히 새로 추가되는 독립 모듈이다. 자체 단위 테스트를 포함하고 있다.

#### 1-1. CommandRisk enum

```rust
pub enum CommandRisk {
    Safe,       // 읽기 전용, 상태 변경 없음
    Elevated,   // 상태를 변경하지만 범위가 제한됨
    Dangerous,  // 시스템 접근 또는 보안 설정 변경
}
```

#### 1-2. classify_command() — 명령어 위험도 분류

텍스트를 받아 CommandRisk로 분류한다. **명령어 내용의 의미를 분석하는 것이 아니라, 접두사와 명령어 이름만으로 판정**한다.

분류 기준:

| 위험도 | 대상 | 이유 |
|--------|------|------|
| **Safe** | `/help`, `/pwd`, `/stop`, `/clear` | 읽기 전용, 정보 표시, 자기 세션 관리 |
| **Safe** | 슬래시 없는 일반 텍스트 (예: `이 파일 분석해줘`) | AI 대화로 전달될 뿐, 봇 명령이 아님 |
| **Elevated** | `/start`, `/allowedtools`, `/availabletools`, `/setpollingtime`, `/debug` | 상태를 변경하지만 범위가 제한됨 |
| **Elevated** | `/down relative/path` (상대경로) | 현재 세션 디렉토리 내 파일 접근 |
| **Elevated** | 알 수 없는 `/명령` | 안전 쪽으로 elevated 처리 |
| **Dangerous** | `!`로 시작하는 모든 것 | 쉘 명령 직접 실행 — 내용 불문 전부 Dangerous |
| **Dangerous** | `/down /absolute/path` 또는 `/down ../escape` | 절대경로 또는 디렉토리 탈출 시도 |
| **Dangerous** | `/allowed`, `/public` | 보안 설정(허용 도구, 공개 모드) 변경 |

`!` 명령어에 대한 핵심 설계:
- `!pwd`든 `!rm -rf /`든 **내용을 구분하지 않고 전부 Dangerous**로 처리한다
- 쉘 명령의 위험도를 정적으로 파싱하는 것은 불가능에 가까우므로, 쉘 접근 자체를 위험한 것으로 분류하는 방식이다
- 이 설계의 목표는 "위험한 쉘 명령만 골라서 막겠다"가 아니라, "비소유자에게는 쉘 접근 자체를 주지 않겠다"이다

`/down`이 특별한 이유 — 인자에 따라 위험도가 달라진다:

```rust
"/down" => {
    let arg = cmd.split_whitespace().nth(1).unwrap_or("");
    if arg.starts_with('/') || arg.starts_with("..") {
        CommandRisk::Dangerous    // 절대경로 또는 상위 탈출
    } else {
        CommandRisk::Elevated     // "file.txt" 같은 상대경로
    }
}
```

#### 1-3. can_execute() — 사용자별 실행 허용 여부 판정

```rust
pub fn can_execute(user_is_owner: bool, is_public: bool, risk: CommandRisk) -> bool {
    if user_is_owner {
        return true;          // Owner는 무조건 통과
    }
    if is_public {
        return risk == CommandRisk::Safe;  // Public 그룹의 비소유자는 Safe만
    }
    false                     // 그 외는 전부 거부
}
```

권한 매트릭스:

```
                │ Safe     │ Elevated │ Dangerous
────────────────┼──────────┼──────────┼──────────
Owner           │ ✅ 허용   │ ✅ 허용   │ ✅ 허용
Public 비소유자  │ ✅ 허용   │ ❌ 차단   │ ❌ 차단
일반 비소유자    │ ❌ 차단   │ ❌ 차단   │ ❌ 차단
```

실제 시나리오 예시 (Public 그룹채팅):

| 사용자 | 입력 | 위험도 | 결과 |
|--------|------|--------|------|
| Owner | `!rm -rf /tmp` | Dangerous | ✅ 통과 |
| 멤버A | `이 파일 분석해줘` | Safe | ✅ 통과 (AI 대화) |
| 멤버A | `/help` | Safe | ✅ 통과 |
| 멤버A | `/start /home/user/project` | Elevated | ❌ Permission denied |
| 멤버A | `!cat /etc/passwd` | Dangerous | ❌ Permission denied |
| 멤버A | `!pwd` | Dangerous | ❌ Permission denied |
| 멤버A | `/down ../../../etc/shadow` | Dangerous | ❌ Permission denied |

#### 1-4. is_path_within_sandbox() — 경로가 sandbox 안에 있는지 체크

```rust
pub fn is_path_within_sandbox(path: &Path, sandbox_root: &Path) -> bool {
    let Ok(canonical_path) = path.canonicalize() else {
        return false;   // canonicalize 실패 → 존재하지 않는 경로 → 거부
    };
    let Ok(canonical_root) = sandbox_root.canonicalize() else {
        return false;
    };
    canonical_path.starts_with(&canonical_root)
}
```

핵심은 `canonicalize()`이다. 심볼릭 링크를 해소하고 `..`을 정리한 절대경로로 변환한 후 비교한다:

```
입력: /home/user/project/../../etc/passwd
           ↓ canonicalize
결과: /etc/passwd

sandbox_root: /home/user
           ↓ canonicalize
결과: /home/user

"/etc/passwd".starts_with("/home/user") → false → 차단
```

심볼릭 링크를 이용한 우회도 방지된다:

```
/home/user/sneaky_link → /etc/passwd  (심볼릭 링크)
  → canonicalize → /etc/passwd
  → "/etc/passwd".starts_with("/home/user") → false → 차단
```

#### 1-5. 단위 테스트 (86~148줄)

auth.rs 자체에 6개의 테스트가 포함되어 있다:

- `test_classify_safe_commands` — Safe 분류 검증 (/help, /pwd, /stop, /clear, 일반 텍스트)
- `test_classify_elevated_commands` — Elevated 분류 검증 (/start, /allowedtools, /down 상대경로 등)
- `test_classify_dangerous_commands` — Dangerous 분류 검증 (!쉘명령, /down 절대경로, /allowed, /public)
- `test_can_execute_owner` — Owner는 모든 위험도 허용
- `test_can_execute_public_non_owner` — Public 비소유자는 Safe만 허용
- `test_can_execute_non_public_non_owner` — 비Public 비소유자는 전부 거부
- `test_path_within_sandbox` — temp_dir이 자기 자신 안에 있는지 기본 검증

---

### 2. 수정 파일: `src/services/mod.rs`

1줄 추가:

```rust
// 변경 전 (현재 main)
pub mod file_ops;
pub mod process;
pub mod claude;
pub mod remote;
pub mod remote_transfer;
pub mod dedup;
pub mod telegram;
```

```rust
// 변경 후
pub mod auth;             // ← 추가
pub mod file_ops;
pub mod process;
pub mod claude;
pub mod remote;
pub mod remote_transfer;
pub mod dedup;
pub mod telegram;
```

---

### 3. 수정 파일: `src/services/telegram.rs` (4곳 삽입)

모든 변경이 기존 코드 사이에 끼워넣는 형태이며, 기존 코드를 수정하지 않는다.

#### 3-A. import 추가 (현재 main 13행 근처)

```rust
// 변경 전 (현재 main)
use sha2::{Sha256, Digest};

use crate::services::claude::{self, CancelToken, StreamMessage, DEFAULT_ALLOWED_TOOLS};
use crate::ui::ai_screen::{self, HistoryItem, HistoryType, SessionData};
```

```rust
// 변경 후
use sha2::{Sha256, Digest};

use crate::services::auth::{classify_command, can_execute, is_path_within_sandbox, CommandRisk};  // ← 추가
use crate::services::claude::{self, CancelToken, StreamMessage, DEFAULT_ALLOWED_TOOLS};
use crate::ui::ai_screen::{self, HistoryItem, HistoryType, SessionData};
```

#### 3-B. Auth check 블록 삽입 (현재 main 947행 뒤)

모든 명령어 분기 처리 직전에 삽입되어, 권한이 없으면 어떤 명령도 실행되지 않도록 한다.

```rust
// 현재 main 946행까지 (기존 코드, 변경 없음)
    // Block all messages except /stop while an AI request is in progress
    if !text.starts_with("/stop") {
        let data = state.lock().await;
        if data.cancel_tokens.contains_key(&chat_id) {
            drop(data);
            shared_rate_limit_wait(&state, chat_id).await;
            tg!("send_message", bot.send_message(chat_id, "AI request in progress. Use /stop to cancel.")
                .await)?;
            return Ok(());
        }
    }

    // ↓↓↓ 여기에 삽입 ↓↓↓

    // Auth check: classify command risk and verify the user has permission
    {
        let chat_key = chat_id.0.to_string();
        let is_public = {
            let data = state.lock().await;
            is_group_chat && data.settings.as_public_for_group_chat.get(&chat_key).copied().unwrap_or(false)
        };
        let risk = classify_command(&text);
        if !can_execute(is_owner, is_public, risk) {
            println!("  [{timestamp}] ✗ Permission denied: [{user_name}] {:?} -> {:?}", text.split_whitespace().next().unwrap_or(""), risk);
            shared_rate_limit_wait(&state, chat_id).await;
            tg!("send_message", bot.send_message(chat_id, "Permission denied.")
                .await)?;
            return Ok(());
        }
    }

    // ↑↑↑ 삽입 끝 ↑↑↑

    // 현재 main 948행부터 (기존 코드, 변경 없음)
    if text.starts_with("/stop") {
        println!("  [{timestamp}] ◀ [{user_name}] /stop");
        handle_stop_command(&bot, chat_id, &state).await?;
```

이 블록의 동작 과정:
1. 현재 채팅의 chat_id를 키로 `as_public_for_group_chat`에서 public 여부를 조회
2. `classify_command(&text)`로 명령어 위험도 분류
3. `can_execute(is_owner, is_public, risk)`로 실행 가능 여부 판정
4. 거부 시 로그 출력 + "Permission denied." 메시지 전송 + 조기 return

참조하는 변수 호환성:
- `is_owner` — 현재 main 827행에서 정의됨 ✅
- `is_group_chat` — 현재 main에서 사용 중 ✅
- `data.settings.as_public_for_group_chat` — 현재 main 74행에 필드 존재 ✅
- `timestamp`, `user_name` — 현재 main에서 사용 중 ✅

#### 3-C. 첫 번째 Sandbox check 삽입 (현재 main 1130행 뒤)

`/start <path>` 명령으로 작업 디렉토리를 설정할 때, 홈 디렉토리 밖 경로를 차단한다.

```rust
// 현재 main 1127~1130행 (기존 코드, 변경 없음)
        path.canonicalize()
            .map(|p| p.display().to_string())
            .unwrap_or_else(|_| expanded)
    };

    // ↓↓↓ 여기에 삽입 ↓↓↓

    // Sandbox check: path must be within user's home directory
    if let Some(home) = dirs::home_dir() {
        let target = std::path::Path::new(&canonical_path);
        if !is_path_within_sandbox(target, &home) {
            shared_rate_limit_wait(state, chat_id).await;
            tg!("send_message", bot.send_message(chat_id, "Error: path is outside the allowed sandbox (home directory).")
                .await)?;
            return Ok(());
        }
    }

    // ↑↑↑ 삽입 끝 ↑↑↑

    // 현재 main 1132행 (기존 코드, 변경 없음)
    // Try to load existing session for this path
    let existing = load_existing_session(&canonical_path);
```

차단 예시:
- `/start /etc` → canonical_path="/etc" → home="/home/user" → 차단
- `/start /home/user/project` → canonical_path="/home/user/project" → 통과

#### 3-D. 두 번째 Sandbox check 삽입 (현재 main 1509행 뒤)

`/down <file>` 명령으로 파일을 다운로드할 때, 홈 디렉토리 밖 파일 접근을 차단한다.

```rust
// 현재 main 1507~1509행 (기존 코드, 변경 없음)
        }
    };

    // ↓↓↓ 여기에 삽입 ↓↓↓

    // Sandbox check: file must be within user's home directory
    if let Some(home) = dirs::home_dir() {
        let target = Path::new(&resolved_path);
        if !is_path_within_sandbox(target, &home) {
            shared_rate_limit_wait(state, chat_id).await;
            tg!("send_message", bot.send_message(chat_id, "Error: path is outside the allowed sandbox (home directory).")
                .await)?;
            return Ok(());
        }
    }

    // ↑↑↑ 삽입 끝 ↑↑↑

    // 현재 main 1510행 (기존 코드, 변경 없음)
    let path = Path::new(&resolved_path);
    if !path.exists() {
```

차단 예시:
- `/down /etc/shadow` → resolved_path="/etc/shadow" → 차단
- `/down /var/log/syslog` → resolved_path="/var/log/syslog" → 차단
- `/down myfile.txt` → resolved_path="/home/user/project/myfile.txt" → 통과

---

## 보안 레이어 전체 흐름

```
메시지 도착
  │
  ▼
기존 체크: 소유자 등록 여부, 그룹 권한 (변경 없음)
  │
  ▼
기존 체크: AI 진행 중이면 /stop 외 차단 (변경 없음)
  │
  ▼
[NEW] ① classify_command → Safe / Elevated / Dangerous
  │
  ▼
[NEW] ② can_execute(is_owner, is_public, risk)
  │    → false면 "Permission denied." 반환
  ▼
명령어별 분기 처리
  │
  ├─ /start <path>
  │    ▼
  │    [NEW] ③ is_path_within_sandbox(path, home_dir)
  │         → false면 "path is outside the allowed sandbox" 반환
  │
  ├─ /down <file>
  │    ▼
  │    [NEW] ④ is_path_within_sandbox(path, home_dir)
  │         → false면 "path is outside the allowed sandbox" 반환
  │
  └─ 기타 명령어 → 기존 로직 그대로
```

②번 Auth check은 **누가 무슨 명령을 보내는지** 기준으로 필터링하고,
③④번 Sandbox check은 **경로가 어디를 가리키는지** 기준으로 필터링한다.
두 레이어가 서로 다른 축으로 방어하는 구조이다.

---

## 이 시스템의 관할 범위와 한계

이 auth 시스템은 **텔레그램 봇의 명시적 명령어(`/`, `!`)에 대한 접근 제어**이다.

자연어 AI 대화를 통한 우회는 이 시스템의 관할 밖이다.
예를 들어 멤버A가 "Please Print Working Directory"라고 보내면:
- `!`도 `/`도 없는 일반 텍스트 → Safe → 통과 → AI 대화로 전달됨
- AI가 실제로 pwd를 실행할지는 AI의 allowed tools 설정에 달린 별개의 문제

즉, 이 시스템의 설계 목표는:
- **비소유자에게 봇 명령어 레벨의 쉘 접근(`!`)을 주지 않는 것**
- **비소유자에게 봇 설정 변경 권한을 주지 않는 것**
- **모든 사용자의 파일 접근 범위를 홈 디렉토리로 제한하는 것**

이며, AI 자연어 대화를 통한 간접 실행까지 제어하는 것은 아니다.

---

## 적용 방법

PR base(before)와 현재 main 사이에 1717줄의 차이가 있지만, PR의 모든 변경이 순수 삽입이므로 충돌 없이 적용 가능하다.

적용 순서:

1. `src/services/auth.rs` — PR after의 파일을 그대로 복사하여 생성
2. `src/services/mod.rs` 1행 — `pub mod auth;` 추가
3. `src/services/telegram.rs` 13행 근처 — auth import 추가
4. `src/services/telegram.rs` 947행 뒤 — Auth check 블록 삽입
5. `src/services/telegram.rs` 1130행 뒤 — 첫 번째 Sandbox check 삽입
6. `src/services/telegram.rs` 1509행 뒤 — 두 번째 Sandbox check 삽입

의존성 확인:
- `dirs` 크레이트 — 현재 main Cargo.toml에 `dirs = "5"` 이미 존재 ✅
- `is_owner` 변수 — 현재 main 827행에 정의 ✅
- `is_group_chat` 변수 — 현재 main에 존재 ✅
- `as_public_for_group_chat` 필드 — 현재 main BotSettings에 존재 ✅
- `shared_rate_limit_wait` 함수 — 현재 main에 존재 ✅
- `tg!` 매크로 — 현재 main에 존재 ✅
